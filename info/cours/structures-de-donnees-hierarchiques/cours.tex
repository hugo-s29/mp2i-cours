\hypertarget{i.-introduction---duxe9finition}{%
\section{I. Introduction -
définition}\label{i.-introduction---duxe9finition}}

\hypertarget{utilisation-des-arbres}{%
\subsection{Utilisation des arbres}\label{utilisation-des-arbres}}

\begin{itemize}
\tightlist
\item
  Arbres syntaxiques
\item
  Arbre lexicographique
\item
  Arbre de décision / classification (ML)
\item
  Compression de données
\item
  Expressions mathématiques
\end{itemize}

\hypertarget{classification}{%
\subsection{Classification}\label{classification}}

\includegraphics{.cache/mermaid/bbf1e2c2d65f4d974713f74eb7ba55f2.pdf}

\hypertarget{duxe9finitions}{%
\subsection{Définitions}\label{duxe9finitions}}

Un arbre (enraciné) est

\begin{itemize}
\tightlist
\item
  soit un ensemble vide
\item
  soit un ensemble fini non vide \(A\) muni d'une relation binaire \(<\)
  (est le fils de \ldots) telle que
\item
  il existe \(r \in A\) tel que \(\forall x \in A, r < x\) (il existe un
  ancêtre)
\item
  \(\forall x \in A \setminus \{r\}, \exists ! y \in A, x < y\) (il y a
  un père unique)
\item
  \(\forall x \in A \setminus \{r\}, \exists n \in \mathbb{N} \text{ et } (x_1, x_2, \ldots, x_n) \in A^n, x < x_1 < x_2 < \cdots < x_n < r\)
  (chaque élément descend de l'ancêtre)
\end{itemize}

On parle aussi de frères, de descendance et d'ancêtres.

L'\emph{arité} d'un père correspond au nombre de ses fils

\includegraphics{.cache/mermaid/d2d157504536d827f37abd6be617c1cf.pdf}

Un \emph{arbre \(n\)-aire} est un arbre dont les nœuds sont d'arité
maximale \(n\) Dans l'exemple, chaque nœud a au maximum une arité de 3
donc l'arbre est un arbre ternaire.

La \emph{taille} de l'arbre est le nombre de nœuds qui le compose. Dans
l'exemple, la taille est 6.

La \emph{profondeur} d'un nœud est:

\begin{itemize}
\tightlist
\item
  -1 si l'arbre est vide
\item
  0 pour la racine
\item
  le nombre de nœuds depuis la racine avant d'atteindre le nœud
\end{itemize}

\includegraphics{.cache/mermaid/6b2c8c9a04fb08f41dae8eb42a6ee6ed.pdf}

Par exemple, le nœud \(N\) a une profondeur de 2.

La \emph{hauteur} de l'arbre est la profondeur maximale de ses feuilles.
Dans l'exemple, la hauteur est de 3.

\hypertarget{duxe9finition-inductive}{%
\subsection{Définition inductive}\label{duxe9finition-inductive}}

Soit \(A\) un ensemble fini appelé nœuds.

\begin{itemize}
\tightlist
\item
  les arbres de hauteur 0 sont les éléments de \(A\) noté \((e,0)\) où
  \(e\) est la racine de l'arbre
\item
  Si \(e \in A\) et Si \(A_1, A_2, \ldots, A_n\) sont des arbres de
  hauteur respectives \(h_1, h_2, \ldots, h_n\) et dont les racines
  respectives sont \(e_1, e_2, \ldots, e_n\), alors en connectant \(e\)
  à \(e_1, e_2, \ldots e_n\), on définit
  \(\big(e, (A_1, A_2, \ldots, A_n)\big)\) l'arbre de racine \(e\), de
  hauteur \(\displaystyle 1 + \max_{k \in [\![ 1,n ]\!]} (h_k)\) de sous
  arbres \(A_1, A_2, \ldots, A_n\)
\end{itemize}

\includegraphics{.cache/mermaid/277731145b4915beccd16b37ca240663.pdf}

\hypertarget{remarques}{%
\subsection{Remarques:}\label{remarques}}

Arbre marqué: Chaque nœud associé à une étiquette / valeur

Arbre non marqué: Les nœuds n'ont pas de valeurs associés

Un arbre est un graph:

\begin{itemize}
\tightlist
\item
  Simple: pas de boucles ou d'arêtes multiples
\item
  Non orienté: les parcours \(a \to b\) et \(b \to a\) sont toujours
  possible
\item
  Acyclique: pas de ``boucles''
\item
  Connexe: tous les nœuds sont accessibles
\end{itemize}

\hypertarget{propriuxe9tuxe9}{%
\subsubsection{Propriété:}\label{propriuxe9tuxe9}}

Pour un arbre de hauteur \(h\) d'arité \(a>1\), le nombre \(n\) de nœuds
vérifie \[ h + 1 \geqslant n \geqslant \frac{a^{h+1} - 1}{a - 1} \]

\hypertarget{preuve}{%
\subsubsection{Preuve:}\label{preuve}}

Le nombre minimal de nœuds pour une hauteur donnée est un arbre
contenant 1 nœud par hauteur. Le nombre maximal de nœuds pour une
hauteur donnée est un arbre contenant \(i\) nœud par niveau \(i\).

\begin{align*}
    &\sum_{i=0}^h 1 \geqslant n \geqslant \sum_{i=0}^h a^i\\
    \iff& h + 1 \geqslant n \geqslant \frac{a^{h+1}-1}{a-1}
\end{align*}

\hypertarget{ii.-arbres-particuliers}{%
\section{II. Arbres particuliers}\label{ii.-arbres-particuliers}}

\hypertarget{duxe9finitions-1}{%
\subsection{Définitions}\label{duxe9finitions-1}}

\hypertarget{arbres-binaires}{%
\subsubsection{Arbres binaires:}\label{arbres-binaires}}

Tous les nœuds sont d'arité au maximum 2.

\includegraphics{.cache/mermaid/2402373c32d3c59902399ab05f3a8da8.pdf}

\hypertarget{arbre-binaire-entier}{%
\subsubsection{Arbre binaire entier:}\label{arbre-binaire-entier}}

Tous les nœuds sont d'arité 2

\includegraphics{.cache/mermaid/a17f815f47bdf0164319125e40db65aa.pdf}

\hypertarget{arbre-binaire-complet}{%
\subsubsection{Arbre binaire complet}\label{arbre-binaire-complet}}

Arbre binaire dont les feuilles ont toutes la même profondeur. Il
possède le nombre maximal de feuilles pour une hauteur donnée. On parle
donc de fils gauche et de fils droit.

\includegraphics{.cache/mermaid/b10cf5f6784f91bc458251813a0bfdb3.pdf}

\hypertarget{propriuxe9tuxe9s}{%
\subsection{Propriétés}\label{propriuxe9tuxe9s}}

Nombre de nœuds \(n \leqslant 2^p\) (pour un niveau \(p\))

Hauteur \(h\): \(\lfloor \log_2(n) \rfloor < h \leqslant n - 1\)

Arbre binaire à \(i\) nœuds interne (et la racine) d'arité 2 et \(f\)
feuilles : \(f = i + 1\)

Nombre de feuilles \(f \leqslant 2^h\)

Profondeur maximale d'un arbre d'arité \(a\) composée de \(n\) nœuds:
\[\log_a\big((a-1)\times n + 1\big) - 1 \leqslant h \leqslant n-1\]

\hypertarget{remarque}{%
\subsubsection{Remarque:}\label{remarque}}

\begin{align*}
    &\log_a((a-1)\times n + 1)  - 1 \le h\\
    \implies& \log_a((a-1)\times n) < \log_a ((a-1) \times n + 1) \le h+1\\
    \implies& \left\lfloor \log_a((a-1)\times n) \right\rfloor< h+1\\
    \implies&\left\lfloor \log_a((a-1)\times n) \right\rfloor \le h
\end{align*}

soit \(\left\lfloor \log_a((a-1)\times n) \right\rfloor\le h \le n-1\)

\hypertarget{transformation-dun-arbre-en-arbre-binaire}{%
\subsection{Transformation d'un arbre en arbre
binaire}\label{transformation-dun-arbre-en-arbre-binaire}}

Algorithme de transformation d'un arbre \(n\)-aire \(A\) en arbre
binaire:

\tt
    Pour chaque $e \in A$\\
        Laisser $e_g$ (fils le plus à gauche) en place\\
        Supprimer les autres fils de $e$ et les chainer à $e_g$\\
        Le nœud $e_d$ est le prochain frère de $e$\\
    Fin pour
\rm

\includegraphics{.cache/mermaid/2218b0ac875ac5e5f2102f6c29164964.pdf}

\includegraphics{.cache/mermaid/6f65ae9de64a7ba5b0d629da95914253.pdf}

\includegraphics{.cache/mermaid/83f3870fde9eaf25121d864d94783adc.pdf}

\includegraphics{.cache/mermaid/625b5f1b170fa675218f2281ea0beae8.pdf}

\includegraphics{.cache/mermaid/1a2bf4619afaae38a6b30011e887f56e.pdf}

\includegraphics{.cache/mermaid/2c4d56150fa3b5322a691b8ffd948af5.pdf}

\includegraphics{.cache/mermaid/b3f4f62ef1585eda4ce070caaf248161.pdf}

Exercice:

\includegraphics{.cache/mermaid/b17b3dfc5efc3ab4a0636376654ea246.pdf}

\includegraphics{.cache/mermaid/a244e81f8cadf24d1533266aad1824d6.pdf}

\hypertarget{arbres-binaires-impluxe9mentation-sous-forme-de-tableau-en-c-suxe9rialisation}{%
\subsection{Arbres binaires : implémentation sous forme de tableau en C
(sérialisation)}\label{arbres-binaires-impluxe9mentation-sous-forme-de-tableau-en-c-suxe9rialisation}}

On stocke un arbre binaire dans un tableau d'enregistrements Chaque
enregistrement E est défini par:

\begin{itemize}
\tightlist
\item
  E.clé : valeur du nœud
\item
  E.gauche : indice du fils gauche dans le tableau
\item
  E.droit : indice du fils droit dans le tableau
\end{itemize}

Une valeur de E.gauche ou E.droit égale à -1 indique qu'il n'existe pas
de fils.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 20\tabcolsep) * \real{0.2889}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 20\tabcolsep) * \real{0.0667}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 20\tabcolsep) * \real{0.0667}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 20\tabcolsep) * \real{0.0556}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 20\tabcolsep) * \real{0.0667}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 20\tabcolsep) * \real{0.0667}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 20\tabcolsep) * \real{0.0778}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 20\tabcolsep) * \real{0.0778}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 20\tabcolsep) * \real{0.0778}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 20\tabcolsep) * \real{0.0778}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 20\tabcolsep) * \real{0.0778}}@{}}
\toprule()
\endhead
Indice dans le tableau & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\
Clé & 23 & 2 & 3 & 5 & 7 & 11 & 13 & 37 & 41 & 19 \\
Gauche & -1 & 5 & ~3 & -1 & -1 & 9 & -1 & 8 & 6 & -1 \\
~Droit & -1 & 4 & ~0 & -1 & -1 & -1 & 2 & 1 & -1 & -1 \\
\bottomrule()
\end{longtable}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Représenter cet arbre. Est-il binaire ? Entier ? Complet ?

  \includegraphics{.cache/mermaid/5602e189a29eb8ca41cf7de6e5510223.pdf}

  C'est un arbre binaire mais il n'est pas complet ni entier.
\item
  Définir le code en C permettant de définir ce tableau (statique)

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ item }\OperatorTok{\{}
        \DataTypeTok{int}\NormalTok{ val}\OperatorTok{;}
        \DataTypeTok{int}\NormalTok{ left}\OperatorTok{;}
        \DataTypeTok{int}\NormalTok{ right}\OperatorTok{;}
    \OperatorTok{\};}

\NormalTok{    item table}\OperatorTok{[}\DecValTok{10}\OperatorTok{];} 
\end{Highlighting}
\end{Shaded}
\item
  Écrire une fonction en C qui renvoie l'enregistrement de la racine

\begin{Shaded}
\begin{Highlighting}[]
    \DataTypeTok{int}\NormalTok{ getRoot}\OperatorTok{(}\NormalTok{item}\OperatorTok{*}\NormalTok{ table}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ len}\OperatorTok{,}\NormalTok{ item}\OperatorTok{*}\NormalTok{ root}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ len}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
            \ControlFlowTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}}\NormalTok{ len}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
                \CommentTok{// on vérifie si i est un fils de j}
                \ControlFlowTok{if}\OperatorTok{(}\NormalTok{table}\OperatorTok{[}\NormalTok{j}\OperatorTok{].}\NormalTok{left }\OperatorTok{==}\NormalTok{ i }\OperatorTok{||}\NormalTok{ table}\OperatorTok{[}\NormalTok{j}\OperatorTok{].}\NormalTok{right }\OperatorTok{==}\NormalTok{ i}\OperatorTok{)} \OperatorTok{\{}
                    \ControlFlowTok{break}\OperatorTok{;} \CommentTok{// nouvelle itération de la boucle exterieure}
                \OperatorTok{\}}
            \OperatorTok{\}}

            \ControlFlowTok{return}\NormalTok{ i}\OperatorTok{;}
        \OperatorTok{\}}

        \CommentTok{// pas de racine, il y a une boucle}
        \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  Solution:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    item getRoot}\OperatorTok{(}\NormalTok{item}\OperatorTok{*}\NormalTok{ table}\OperatorTok{)} \OperatorTok{\{}
        \DataTypeTok{int}\NormalTok{ search}\OperatorTok{[}\DecValTok{10}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{0}\OperatorTok{\};}

        \ControlFlowTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{10}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
            \ControlFlowTok{if}\OperatorTok{(}\NormalTok{table}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{left }\OperatorTok{!=} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{                search}\OperatorTok{[}\NormalTok{table}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{left}\OperatorTok{]} \OperatorTok{=} \DecValTok{1}\OperatorTok{;}
            \OperatorTok{\}}

            \ControlFlowTok{if}\OperatorTok{(}\NormalTok{table}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{right }\OperatorTok{!=} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{                search}\OperatorTok{[}\NormalTok{table}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{right}\OperatorTok{]} \OperatorTok{=} \DecValTok{1}\OperatorTok{;}
            \OperatorTok{\}}
        \OperatorTok{\}}

        \ControlFlowTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{10}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
            \ControlFlowTok{if}\OperatorTok{(}\NormalTok{search}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
                \ControlFlowTok{return}\NormalTok{ table}\OperatorTok{[}\NormalTok{i}\OperatorTok{];}
        \OperatorTok{\}}
    \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  Solution 2:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    item getRoot}\OperatorTok{(}\NormalTok{item}\OperatorTok{*}\NormalTok{ table}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ len}\OperatorTok{)} \OperatorTok{\{}
        \DataTypeTok{int}\NormalTok{ root }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

        \ControlFlowTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ len}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{            root }\OperatorTok{+=}\NormalTok{ i}\OperatorTok{;}

            \ControlFlowTok{if}\OperatorTok{(}\NormalTok{table}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{left }\OperatorTok{!=} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{                root }\OperatorTok{{-}=}\NormalTok{ table}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{left}\OperatorTok{;}
            \OperatorTok{\}}

            \ControlFlowTok{if}\OperatorTok{(}\NormalTok{table}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{right }\OperatorTok{!=} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{                root }\OperatorTok{{-}=}\NormalTok{ table}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{right}\OperatorTok{;}
            \OperatorTok{\}}
        \OperatorTok{\}}

        \ControlFlowTok{return}\NormalTok{ table}\OperatorTok{[}\NormalTok{root}\OperatorTok{];}
    \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Écrire une fonction en C qui affiche la valeur de toutes les feuilles
  de T

\begin{Shaded}
\begin{Highlighting}[]
    \DataTypeTok{void}\NormalTok{ showValues}\OperatorTok{(}\NormalTok{item}\OperatorTok{*}\NormalTok{ table}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ len}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        item root}\OperatorTok{;}
        \DataTypeTok{int}\NormalTok{ rootIndex }\OperatorTok{=}\NormalTok{ getRoot}\OperatorTok{(}\NormalTok{table}\OperatorTok{,}\NormalTok{ len}\OperatorTok{,} \OperatorTok{\&}\NormalTok{root}\OperatorTok{);}

\NormalTok{        showChildValues}\OperatorTok{(}\NormalTok{rootIndex}\OperatorTok{,}\NormalTok{ table}\OperatorTok{);}
    \OperatorTok{\}}

    \DataTypeTok{void}\NormalTok{ showChildValues}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ index}\OperatorTok{,}\NormalTok{ item}\OperatorTok{*}\NormalTok{ table}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        item val }\OperatorTok{=}\NormalTok{ table}\OperatorTok{[}\NormalTok{index}\OperatorTok{];}

        \ControlFlowTok{if}\OperatorTok{(}\NormalTok{val}\OperatorTok{.}\NormalTok{left }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{1} \OperatorTok{\&\&}\NormalTok{ val}\OperatorTok{.}\NormalTok{right }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"\%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ val}\OperatorTok{.}\NormalTok{val}\OperatorTok{);}
        \OperatorTok{\}}

        \ControlFlowTok{if}\OperatorTok{(}\NormalTok{val}\OperatorTok{.}\NormalTok{left }\OperatorTok{!=} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} 
\NormalTok{            showChildValues}\OperatorTok{(}\NormalTok{val}\OperatorTok{.}\NormalTok{left}\OperatorTok{,}\NormalTok{ table}\OperatorTok{);}

        \ControlFlowTok{if}\OperatorTok{(}\NormalTok{val}\OperatorTok{.}\NormalTok{right }\OperatorTok{!=} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} 
\NormalTok{            showChildValues}\OperatorTok{(}\NormalTok{val}\OperatorTok{.}\NormalTok{right}\OperatorTok{,}\NormalTok{ table}\OperatorTok{);}
    \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  Solution:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ showValues}\OperatorTok{(}\NormalTok{item}\OperatorTok{*}\NormalTok{ table}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ len}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ len}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}

        \CommentTok{// uniquement vrai si gauche = droite = {-}1}
        \ControlFlowTok{if}\OperatorTok{(}\NormalTok{table}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{left }\OperatorTok{==}\NormalTok{ table}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{right}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"\%d"}\OperatorTok{,}\NormalTok{ table}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{val}\OperatorTok{);}
        \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{arbres-binaires-de-recherche}{%
\subsection{Arbres binaires de
recherche}\label{arbres-binaires-de-recherche}}

Arbre binaire marqué:

\begin{itemize}
\item
  Présence d'une étiquette pour chaque nœud \(x\) de A
\item
  Étiquettes

  \begin{itemize}
  \tightlist
  \item
    Même type
  \item
    Présence d'une clé appartenant à un ensemble \(E\)
  \item
    Relation d'ordre total sur \(E\)
  \item
    Notation \(x.\mathrm{clé}\)
  \end{itemize}
\end{itemize}

Organisation de l'arbre binaire de recherche: soit un nœud \(x\) de
\(A\).

\begin{itemize}
\item
  Alors toutes les étiquettes des nœuds \(y\) des sous arbres gauches de
  \(x\) sont telles que \(y.\mathrm{clé} \leqslant x.\mathrm{clé}\)
\item
  Et toutes les étiquettes des nœuds \(y\) des sous arbres droits de
  \(x\) sont telles que \(y.\mathrm{clé} \geqslant x.\mathrm{clé}\)
\end{itemize}

Exemples:

\includegraphics{.cache/mermaid/2e667564425ba930c9291878cba47652.pdf}

\includegraphics{.cache/mermaid/ddd22a3225277dc0ffb9beecbe1ab869.pdf}

Nœud:

\begin{itemize}
\tightlist
\item
  Étiquette

  \begin{itemize}
  \tightlist
  \item
    clé
  \item
    information
  \end{itemize}
\item
  Fils gauche
\item
  Fils droit
\end{itemize}

Opérations fondamentales des ABR:

\begin{itemize}
\tightlist
\item
  Constructeur
\item
  Accesseurs

  \begin{itemize}
  \tightlist
  \item
    Recherche d'une clé
  \item
    Rechercher le minimum
  \item
    Rechercher le maximum
  \item
    Rechercher un successeur
  \item
    Rechercher un prédécesseur
  \end{itemize}
\item
  Transformateurs

  \begin{itemize}
  \tightlist
  \item
    Insérer un nœud
  \item
    Supprimer un nœud
  \end{itemize}
\end{itemize}

Utilité: faciliter une recherche avec une recherche par clé dans l'ABR

\begin{itemize}
\tightlist
\item
  temps de recherche proportionnel à la hauteur \(h\) de l'arbre

  \begin{itemize}
  \tightlist
  \item
    \(T(n) = \mathcal{O}(n)\) recherche linéaire dans le pire des cas
    (liste chainée)
  \item
    \(T(n) = \mathcal{O}\big(\log_2(n)\big)\) recherche en temps
    logarithmique en moyenne pour un ABR complet.
  \end{itemize}
\item
  Dépend de la construction de l'arbre:
\end{itemize}

\includegraphics{.cache/mermaid/79016fce9af629808dc8589a3db0670d.pdf}

6 nœuds, hauteur 2 : Efficace

\includegraphics{.cache/mermaid/de5c8dcd17b9926b391df81c93b8e7a1.pdf}

6 nœuds, hauteur 4 : Peu efficace

L'efficacité augment quand la hauteur diminue.

Arbre dégénéré (filiforme) : chaque nœud n'a qu'un enfant.

\hypertarget{arbres-binaires-bicolores-rouge---noir}{%
\subsection{Arbres binaires bicolores (rouge -
noir)}\label{arbres-binaires-bicolores-rouge---noir}}

Arbre de recherche: possibilité d'arbre déséquilibré (filiforme,
dégénéré)

\begin{itemize}
\tightlist
\item
  Recherche en \(\mathcal{O}(n)\) où \(n\) est le nombre de nœuds
\item
  aucun apport par rapport à une liste chainée
\end{itemize}

Arbre bicolore: arbre de recherche particulier, approximativement
équilibré

\begin{itemize}
\tightlist
\item
  Recherche en \(\Theta\big(\log_2(n)\big)\)
\end{itemize}

Arbre binaire bicolore \(\to\) marqué

\begin{itemize}
\tightlist
\item
  présence d'une étiquette pour chaque nœud \(x\) de \(A\)
\item
  Fils gauche, fils droit
\item
  Étiquettes

  \begin{itemize}
  \tightlist
  \item
    même type
  \item
    clé
  \item
    information
  \item
    information supplémentaire : \emph{couleur} (1 bit)
  \end{itemize}
\end{itemize}

Propriétés rouge noir:

\begin{itemize}
\tightlist
\item
  chaque nœud est soit rouge, soit noir
\item
  chaque feuille est noire
\item
  la racine est noire
\item
  si un nœud est rouge, ses deux enfants sont noirs
\item
  pour chaque nœud, tous les chemins simples reliant le nœud à des
  feuilles situées plus bas dans l'arbre contiennent le même nombre de
  nœuds noirs
\end{itemize}

Remarque:

\begin{itemize}
\tightlist
\item
  Ajout de nœuds noirs vide (pointeur sur NIL) pour générer les feuilles
\item
  Informations contenues dans les nœuds internes
\end{itemize}

Exemple:

Les nœuds rouges sont entre \([ ]\) et les nœuds noirs entre
\(\langle \rangle\)

\includegraphics{.cache/mermaid/db92b9c5c0bf6452fc930b0aa921b945.pdf}

\includegraphics{.cache/mermaid/4cdb319a075f349ea1bd3e57fdd4c609.pdf}

T.NIL : sentinelle

\begin{itemize}
\tightlist
\item
  Simplification des conditions aux limites
\item
  Même attributs qu'un nœud ordinaire:

  \begin{itemize}
  \tightlist
  \item
    Valeur: noir
  \item
    Autres attributs: valeurs quelconques
  \end{itemize}
\item
  Aussi parent de la racine
\end{itemize}

Hauteur noire omise

\includegraphics{.cache/mermaid/b58538deaee351551b87dd032593058d.pdf}

Propriété rouge - noire : la longueur \(L\) d'un chemin allant de la
racine à une feuille est comprise entre \(h_n\) et \(2h_n\).

Chemin: suite de nœuds dont chacun est le prédécesseur ou le successeur
du suivant.

\(h_n\) étant la profondeur noire de l'arbre.

\textbf{Justification:}

Si tous les nœuds sont noirs, alors \(h_n\) est égale à la profondeur de
l'arbre.

S'il y a systématiquement une alternance entre nœuds rouges et noirs,
alors la hauteur totale \(h\) de l'arbre vaut \(2h_n\)

Exercice 1:

\begin{itemize}
\tightlist
\item
  Arbre 1 : non (rouge \(\to\) rouge)
\item
  Arbre 2 : non (racine rouge)
\item
  Arbre 3 : non (nombre de nœuds noirs \(\neq\))
\item
  Arbre 4 : non (n'est pas un ABR car 10 \textless{} 22)
\end{itemize}

Exercice 2:

\includegraphics{.cache/mermaid/3cbfe09f32cce6f8b11ab5c8dbfc035d.pdf}

Exercice 3:

\includegraphics{.cache/mermaid/bb824f73c605606baa0bef3f9d66b469.pdf}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  hauteurs \(h_n(30) = 3\), \(h_n(20) = 3\), \(h_n(35) = 2\) et
  \(h_n(50) = 1\)
\item
  Dans le meilleur des cas, il n'y a pas de nœuds rouges, donc
  \(h = h_n\) et donc le nombre de feuille \(f\) vaut \(2^h\) donc
  \(2^{h_n(x)}\). Or, le nombre de nœuds internes \(i\) valide
  \(f = i + 1\) donc \(i = f - 1\) et donc
  \(i \geqslant 2^{h_n(x)} - 1\)
\item
  Dans le meilleur des cas, on a \(h = h_n\). \begin{align*}
      i \geqslant 2^{h_n(x)} - 1 \iff&
      i + 1 \geqslant 2^{h_n(x)}\\ \iff&
      \log_2(i+1) \geqslant h_n(x) = h
  \end{align*}
\end{enumerate}

\hypertarget{iii.-parcours-darbres}{%
\section{III. Parcours d'arbres}\label{iii.-parcours-darbres}}

\hypertarget{duxe9finition}{%
\subsection{Définition}\label{duxe9finition}}

Soit un arbre \(A\) de taille \(n\).

Objectif:

\begin{itemize}
\tightlist
\item
  visiter les nœuds pour traitement
\item
  contrainte: chaque nœud doit être traité une seule fois
\end{itemize}

Définition:

Un parcours d'arbre est une succession de nœuds
\((n_1, n_2, \ldots, n_n)\), indiquant l'ordre dans lequel ils ont été
visités

Pricipe général des parcours d'arbre :

\begin{itemize}
\tightlist
\item
  marquage du nœud après sont traitement pour ne plus le traiter
\item
  maintien d'un ensemble de nœuds en attente de traitement
\end{itemize}

Existence de plusieurs manières de parcourir un arbre

\hypertarget{utilisation-des-arbres-1}{%
\subsection{Utilisation des arbres}\label{utilisation-des-arbres-1}}

Arbres d'expression \(\to\) représentation d'expressions

\begin{itemize}
\tightlist
\item
  Arbre syntaxique
\item
  Expressions mathématiques
\end{itemize}

Arbres préfixes (ou trie) \(\to\) représentation d'un ensemble de mots

\[ %FAIRE LE GRAPH
\]

\hypertarget{parcours-en-profondeur}{%
\subsection{Parcours en profondeur}\label{parcours-en-profondeur}}

\hypertarget{duxe9finitions-2}{%
\subsubsection{Définitions}\label{duxe9finitions-2}}

Principe de parcours en profondeur:

\begin{itemize}
\tightlist
\item
  Utilisation de la définition inductive des arbres
\item
  Proposition d'algorithmes récursifs
\end{itemize}

\(\implies\) Exploration d'un des sous-arbres avant d'explorer le
sous-arbre suivant

Plusieurs posibilités:

\begin{itemize}
\tightlist
\item
  Exploration en partant de la racine
\item
  Exploration en partant des feuilles
\item
  Exploration symétrique
\end{itemize}

Remarque: Le choix de traiter de gauche à doite est arbitraire.

Ordre préfixé:

\begin{itemize}
\tightlist
\item
  Départ à la racine
\item
  Exploration préfixe du sous-arbre gauche
\item
  Exploration préfixe du sous-arbre droit
\item
  \(\vdots\)
\item
  Exploration du sous-arbre \(A_n\)
\end{itemize}

Pour un arbre binaire, ordre = père, fils gauche, fils droit.

Pour l'arbre ci-dessous, l'ordre préfixé est \[
a \to b \to e \to h \to i \to f \to c \to d \to g \to j \to k \to o \to p \to q \to l \to m \to n
\]

\includegraphics{.cache/mermaid/e640090d50a1b8cd9bc59d9daf2e850b.pdf}

Ordre infixé ou parcours symétrique:

\begin{itemize}
\tightlist
\item
  Exploration infixé du sous-arbre gauche
\item
  Puis racine
\item
  Exploration infixé du sous-arbre droit
\item
  \(\vdots\)
\item
  Exploration des nœuds de \(A_n\) en ordre infixé
\end{itemize}

Pour un arbre binaire, ordre : fils gauche, père, fils droit.

Pour un ABR : ordre infixé

\begin{itemize}
\tightlist
\item
  Obtention de la suite ordonnée des étiquettes
\end{itemize}

Pour l'arbre précédent, l'ordre infixé est \begin{align*}
h \to e \to i \to b \to f \to a \to c \to j \to g \to o \to k \to p \to q \to l \to m \to n \to d
\end{align*}

Ordre postfixé:

\begin{itemize}
\tightlist
\item
  Exploration postfixé du sous-arbre gauche
\item
  Exploration postfixé du sous-arbre droit
\item
  \(\vdots\)
\item
  Exploration du sous-arbre \(A_n\)
\item
  Traitement de la racine
\end{itemize}

Pour une arbre binaire, l'ordre est fils gauche, fils droit, père

Parcours en profondeur de l'arbre précédent : \begin{align*}
    h \to i \to e \to f \to b \to c \to j \to o \to p \to q \to k \to l \to m \to n \to g \to d \to a
\end{align*}

\hypertarget{parcours-en-profondeur-arbre-dexpression}{%
\subsection{Parcours en profondeur : arbre
d'expression}\label{parcours-en-profondeur-arbre-dexpression}}

Problème lié aux expressions infixes : gestion des parenthèses

\(\left(1 + 2 \times \sqrt3\right) / 4\) pour \(\frac{1 + 2\sqrt3}4\)

Représentation d'une expression sous forme d'arbre :

\includegraphics{.cache/mermaid/1e49d0597d7a223e65f0980537482ebc.pdf}

Parcours de l'arbre :

\begin{itemize}
\tightlist
\item
  Infixe : \((1~+~(2~\times~\sqrt{3}))~/~4\)
\item
  Préfixe : \(/~(+~1~(\times~2~\sqrt3))~4\)
\item
  Postfixe : \((1~(2~(3~\sqrt{~})~\times)~+)~4~/\)
\end{itemize}

Notation polonaise inversée (NPI):

\begin{itemize}
\tightlist
\item
  Notation postfixé
\item
  Nécessité de deux piles :

  \begin{itemize}
  \tightlist
  \item
    pile d'expression
  \item
    pile de calcul
  \end{itemize}
\end{itemize}

\(\frac{9}{(2 + (-3)) \times (4 - (-5))}\)

\includegraphics{.cache/mermaid/48f517a91ea56204383e67f7009a5cc4.pdf}

Infixe : \(9~\div~(~(2~+~(-3)~)~\times~(4~-~(-5)~)~)\)

Préfixe : \(\div~9~(\times~~(~+~2~(-~3)~)~(~-~4~(-~5)~)~)\)

Postfixe : \(9~(~(~2~(3~-)~+~)~(~4~(5~-)~-~)~\times~)~\div\)

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 24\tabcolsep) * \real{0.1134}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 24\tabcolsep) * \real{0.0412}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 24\tabcolsep) * \real{0.0412}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 24\tabcolsep) * \real{0.0412}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 24\tabcolsep) * \real{0.0825}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 24\tabcolsep) * \real{0.0825}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 24\tabcolsep) * \real{0.0722}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 24\tabcolsep) * \real{0.0722}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 24\tabcolsep) * \real{0.0825}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 24\tabcolsep) * \real{0.0722}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 24\tabcolsep) * \real{0.1134}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 24\tabcolsep) * \real{0.0928}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 24\tabcolsep) * \real{0.0928}}@{}}
\toprule()
\endhead
Etape & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\
Mot lu & 9 & 2 & 3 & neg & \(+\) & 4 & 5 & neg & \(-\) & \(\times\) &
\(\div\) & \\
Pile & 9 & 2 & 3 & \(-3\) & \(-1\) & \(-1\) & 5 & \(-5\) & 9 & \(-9\) &
\(-9\) & \(-1\) \\
& & 9 & 2 & 2 & 9 & 9 & 4 & 4 & \(-1\) &
\begin{minipage}[t]{\linewidth}\raggedright
\begin{verbatim}
 9
\end{verbatim}
\end{minipage} & 9 & \\
& & & 9 & 9 & & & \(-1\) & \(-1\) & 9 & & & \\
& & & 9 & 9 & & & & 9 & & & & \\
\bottomrule()
\end{longtable}

Parcours de l'arbre \(\to\) utilisation d'une pile

Visite des fils droits avant les fils gauches pour retrouver l'ordre
préfixe (fils gauche en somme de pile)

Pile :

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.0556}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.0556}}@{}}
\toprule()
\endhead
1 & \\
3 & 2 \\
3 & 4 \\
3 & \\
6 & 5 \\
6 & 7 \\
6 & \\
\bottomrule()
\end{longtable}

Clés traité: \(1\to2\to4\to3\to5\to7\to6\)

\includegraphics{.cache/mermaid/951e33036fe6e0bad9e9e73b5dbb9051.pdf}

\hypertarget{bilan}{%
\subsubsection{Bilan}\label{bilan}}

Parcours d'un arbre \(\to\) fonction récursive

Comportement d'une pile

Depth First Search (DFS)

\begin{verbatim}
Fonction ParcoursArbre(Élément)
  Entrée: pointeur sur un nœud de l'arbre
  Sortie: traitement sur chacun des nœuds du sous-arbre enraciné en un élément
  Début
    Si Élément != NIL Alors
      Traitement Élément     != parcours préfixé
      Parcours arbre.gauche
      Traitement Élément     != parcours infixé
      Parcours arbre.droit
      Traitement Élément     != parcours postfixé
    Fin Si
  Fin
\end{verbatim}

\hypertarget{parcours-en-largeur}{%
\subsection{Parcours en largeur}\label{parcours-en-largeur}}

Principe du parcours en largeur :

\begin{itemize}
\tightlist
\item
  Départ de la racine
\item
  Exploration des nœuds par niveaux de l'arbre
\item
  Pour un même niveau, parcours de gauche à droite
\end{itemize}

\(\implies\) Parcours réalisé à l'aide d'une file

Visite des fils gauches avant les fils droits

Parcours intéressant pour

\begin{itemize}
\tightlist
\item
  une recherche avec la plus petite profondeur possible
\item
  pour une énumération
\end{itemize}

\includegraphics{.cache/mermaid/951e33036fe6e0bad9e9e73b5dbb9051.pdf}

File:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.0556}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.0556}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.0556}}@{}}
\toprule()
\endhead
1 & & \\
3 & 2 & \\
4 & 3 & \\
6 & 5 & 4 \\
6 & 5 & \\
7 & 6 & \\
7 & & \\
\bottomrule()
\end{longtable}

Clés traitées: \(1\to 2\to 3\to 4\to 5\to 6\to 7\)

\hypertarget{iv.-impluxe9mentation}{%
\section{IV. Implémentation}\label{iv.-impluxe9mentation}}

\hypertarget{arbres-binaires-de-recherche-1}{%
\subsection{Arbres binaires de
recherche}\label{arbres-binaires-de-recherche-1}}

Type arbre n'existe pas \(\to\) sérialisation (stockage sous un autre
format)

Deux implémentations possibles :

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Par tableaux (voir exercice)
\item
  Par enregistrement et pointeurs
\end{enumerate}

Solution par enregistrement:

\begin{itemize}
\tightlist
\item
  Création du type nœud
\item
  Creation du type arbre pointant sur la racine de l'arbre (en C)
\item
  Arbre complet contenu dans un enregistrement d'enregistrements (en
  OCAML)
\end{itemize}

\begin{quote}
\begin{quote}
\(\implies\) structure récursive
\end{quote}
\end{quote}

Quels champs pour un nœud ?

\begin{itemize}
\tightlist
\item
  entier \texttt{clé}
\item
  pointeur \texttt{fils\_gauche}
\item
  pointeur \texttt{fils\_droit}
\item
  pointeur \texttt{parent}
\item
  enregistrement \texttt{informations}
\end{itemize}

En C, nécessité d'écrire une fonction créant un nœud :

\begin{itemize}
\tightlist
\item
  Entrée:

  \begin{itemize}
  \tightlist
  \item
    valeur (\texttt{int})
  \item
    info (enregistrement contenu dans le nœud)
  \end{itemize}
\item
  Sortie:

  \begin{itemize}
  \tightlist
  \item
    pointeur sur le nœud créé (les champs \texttt{fils\_gauche},
    \texttt{fils\_droit} et \texttt{parent} sont initialisé à
    \texttt{NULL})
  \end{itemize}
\end{itemize}

Constructeur : créer un arbre

\begin{itemize}
\tightlist
\item
  Entrée : aucun
\item
  Sortie : pointeur sur la racine, qui peut être
  \texttt{NULL}/\texttt{NIL}
\item
  Sémantique :

  \begin{itemize}
  \tightlist
  \item
    Fonction créant un pointeur sur la racine
  \item
    Pointeur sur la racine initialisé à \texttt{NULL}/\texttt{NIL}
  \end{itemize}
\end{itemize}

Transformateur : insérer un nouveau nœud \(\to\) nouvelle feuille.
Plusieurs cas à envisager :

\begin{itemize}
\item
  Arbre vide \(\to\) insérer au niveau de la racine
\item
  Arbre non vide

  \begin{itemize}
  \tightlist
  \item
    Début de la racine
  \item
    Parcours de l'arbre par chemin descendant à la recherche d'un
    \texttt{NULL}/\texttt{NIL}
  \item
    Pointeur sur nœud, descendant l'arbre jusqu'à \texttt{NIL} (pointeur
    de traine)
  \item
    Mise à jour du parent de nouveau
  \item
    Mise à jour du fils gauche / droit du futur parent
  \item
    Nécessité d'un pointeur temporaire conservant l'adresse du futur
    parent
  \item
    Mise à jour dans la boucle du pointeur sur parent
  \end{itemize}
\end{itemize}

\begin{quote}
\begin{quote}
\(\implies\) Deux phases :
\end{quote}
\end{quote}

\begin{quote}
\begin{quote}
\begin{quote}
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Recherche de la feuille
\item
  Modification de l'arbre / mise à jours des nœuds
\end{enumerate}
\end{quote}
\end{quote}
\end{quote}

\begin{quote}
Cette fonction est linéaire en temps : \(\mathcal{O}(h)\) où \(h\) est
la hauteur de l'arbre.
\end{quote}

Transformateur : Supprimer un nœud

\begin{itemize}
\tightlist
\item
  Argument : pointeur sur l'arbre, valeur de la clé
\item
  Retourne : arbre modifié
\item
  Sémantique : ?
\end{itemize}

\begin{quote}
Quel cas envisager ?
\end{quote}

\begin{quote}
\begin{quote}
Il faut vérifier que la clé est présent dans l'arbre
\end{quote}
\end{quote}

\begin{quote}
\begin{quote}
Suppression d'une feuille
\end{quote}
\end{quote}

\begin{quote}
\begin{quote}
Suppression d'un nœud interne / racine ayant un seul enfant
\end{quote}
\end{quote}

\begin{quote}
\begin{quote}
Suppression d'un nœud interne / racine ayant deux enfants
\end{quote}
\end{quote}

\begin{itemize}
\item
  Suppression d'une feuille : modification du parent et suppression de
  la feuille
\item
  Suppression d'un nœud interne / racine ayant un seul enfant

  \begin{itemize}
  \tightlist
  \item
    modification du parent (Parent.gauche ou Parent.doit pointe sur
    l'enfant non nul du nœud supprimé)
  \item
    modification de l'enfant (Enfant.parent pointe sur le parent du nœud
    supprimé)
  \end{itemize}
\item
  Suppression d'un nœud interne / racine ayant deux enfants

  \begin{itemize}
  \tightlist
  \item
    Enfant droit est le \emph{successeur} (la définition est après) du
    nœud à supprimer
  \item
    Enfant droit devient le fils de Parent à la place du nœud à
    supprimer: mise à jour de Parent.gauche et de Enfant droit.parent
  \item
    Enfant gauche devient le fils gauche de Enfant droit : mise à jours
    de Enfant droit.gauche et Enfant gauche.parent
  \end{itemize}
\end{itemize}

Prédécesseurs et successeurs : Si toutes les clés sont distinctes, le
successeur d'un nœud \(x\) est le nœud \(y\) possédant la plus petite
clé supérieure à \(x\).clé

Les algorithmes sont sur la feuille ``Structures hiérarchiques ---
Arbres'' mais uniquement pour information : on n'a pas à savoir les
écrire.

\hypertarget{arbre-bicolore}{%
\subsection{Arbre bicolore}\label{arbre-bicolore}}

Modification du type : ajout d'un champ pour désigner la couleur

Opérations d'insertion et de suppression :

\begin{quote}
\(\to\) visite des nœuds pour préserver les propriétés des arbres
bicolores
\end{quote}

\large\sc Non Traité
\normalsize\rm (aucune indication dans le programme)

\hypertarget{uxe9quilibrage-des-arbres-arbres-binaires-de-recherche}{%
\subsection{Équilibrage des arbres (arbres binaires de
recherche)}\label{uxe9quilibrage-des-arbres-arbres-binaires-de-recherche}}

Préservation des propriétés de l'arbre binaire de recherche

Utile pour équilibrage des arbres

\begin{quote}
\(\to\) se rapprocher d'un arbre entier
\end{quote}

\begin{quote}
\(\to\) éviter les arbres filiformes (car la recherche est en
\(\mathcal{O}(n)\))
\end{quote}

Arbre H-équilibré:

\begin{quote}
Déséquilibre d'un arbre en \(a\) : \[
\mathrm{déséquilibre}(a) = h\big(\mathrm{gauche}(a)\big) - h\big(\mathrm{droit}(a)\big)
\]
\end{quote}

\begin{quote}
Un arbre \(a\) est H-équilibré si, pour tous ses sous--arbres \(b\) on a
: \[
\mathrm{déséquilibre}(b)\in\{-1,0,1\}
\]
\end{quote}

\begin{quote}
Un arbre AVL (Adelson -- Velskii -- Landis en 1962) est un arbre
H-équilibré.
\end{quote}

Arbre initial :

\includegraphics{.cache/mermaid/fcad2f45a2fca948e53a33d9b275d168.pdf}

Après une rotation gauche, on a

\includegraphics{.cache/mermaid/f7b2258c973e59e2d85ea4a6c587df78.pdf}

Après une rotation droite, on retrouve l'arbre initial.

Rotation gauche : \(x\) va à droite

Rotation droite : \(y\) va à gauche

Exercice 1 :

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Arbre \(A_1\)

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    \(\mathrm{déséquilibre}(A_1) = 3 - 3 = 0\), il est donc H-équilibré
  \item
    \includegraphics{.cache/mermaid/e21401d14762a14055584db49f375ca7.pdf}

    Après une rotation à droite de centre le nœud \(3\) :

    \includegraphics{.cache/mermaid/dcfde018333f7f2eee8786d6387769b7.pdf}

    Après la rotation à gauche de centre le nœud \(14\) :

    \includegraphics{.cache/mermaid/40d67a0f32bf422ec0ffc3b68ed1a04a.pdf}
  \end{enumerate}

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \setcounter{enumii}{1}
  \item
    Arbre \(A_2\)

    \begin{enumerate}
    \def\labelenumiii{\alph{enumiii}.}
    \tightlist
    \item
      \(\mathrm{déséquilibre}(A_2) = 0\)
    \item
      Rotation à gauche de centre \(5\) puis à droite de centre \(14\)
    \end{enumerate}
  \end{enumerate}
\end{enumerate}

\hypertarget{v.-tas-et-files-de-priorituxe9}{%
\section{V. Tas et files de
priorité}\label{v.-tas-et-files-de-priorituxe9}}

\hypertarget{tas-duxe9finition}{%
\subsection{Tas : définition}\label{tas-duxe9finition}}

Un tas est un arbre binaire :

\begin{itemize}
\tightlist
\item
  tel que (condition sur le squelette) : toutes les feuilles sont de
  profondeur \(h\) ou \(h - 1\). Pour toute profondeur \(p < h\), il y a
  exactement \(2^p\) nœuds. Toutes les feuilles (de profondeur \(h\))
  sont le plus à gauche de l'arbre
\item
  tournoi (condition sur les étiquettes) : l'étiquette d'un nœud est
  supérieure (inférieure) ou égale à celles de ses fils
\end{itemize}

Tas max : l'étiquette d'un nœud est supérieure ou égale à celles de ses
fils.

Tas min : l'étiquette d'un nœud est inférieure ou égale à celles de ses
fils.

Structure bin adaptée pour gérer les files de priorité :

\begin{quote}
implémentation : (priorité, élément)
\end{quote}

\begin{quote}
la priorité sert de clé
\end{quote}

Exercice : construire 3 tas max contenant les nœuds de clés
\(\{8, 10, 14, 15, 16, 17, 20\}\)

\includegraphics{.cache/mermaid/860240319c82f3ab6e7f818ce150ec06.pdf}

\includegraphics{.cache/mermaid/551656c4a865cadb8c9f37ae35cc5611.pdf}

\includegraphics{.cache/mermaid/5feacafffe9e0e950fd93c884e53c569.pdf}

\hypertarget{impluxe9mentation-des-tas}{%
\subsection{Implémentation des tas}\label{impluxe9mentation-des-tas}}

Implémentation dans un tableau :

\begin{itemize}
\tightlist
\item
  Chaque nœud correspond à un élément du tableau
\item
  Fils gauche d'un nœud \(i\) stocké à l'indice \(2i\)
\item
  Fils droit d'un nœud \(i\) stocké à l'indice \(2i + 1\)
\item
  Parent d'un nœud \(i\) stocké à l'indice
  \(\left\lfloor \frac{i}{2} \right\rfloor\)
\end{itemize}

Tableau \(A\) représentant un tas : deux attributs (algorithmique) :

\begin{itemize}
\tightlist
\item
  \(A\).longueur : nombre d'éléments dans un tableau,
\item
  \(A\).taille : nombre d'éléments dans le tas,
\item
  Le premier élément du tableau \(A\) est la racine du tas,
\item
  On a \(A\).longueur \(\leqslant\) \(A\).taille.
\end{itemize}

Possibilités :

\begin{itemize}
\tightlist
\item
  Stocker la taille du tas à l'indice 0 du tableau lors de la
  programmation,
\item
  Définir un enregistrement contenant la taille du tas et le tableau.
\end{itemize}

\includegraphics{figures/tas.svg}

Exercice 2:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Au maximum, on a un arbre complet de hauteur \(h\) donc
  \(2^{h+1} - 1\) nœuds. Au minimum, on a un arbre complet de hauteur
  \(h - 1\) et le nœud le plus à gauche à un fils gauche. On a donc au
  minimum \(2^h\) nœuds.
\item
\end{enumerate}

\includegraphics{.cache/mermaid/55b52e6274033eed29a1e4213bdf35dd.pdf}

\begin{quote}
Cet arbre n'est pas un tas max car \(7 > 6\). Il faut donc enlever 7 et
12 : \[ [\;23, 17, 14, 6, 13, 10, 1, 5\;] \] La taille de ce tas est 8.
\end{quote}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  On suppose que le nœud stocké en
  \(\left\lfloor \frac{n}{2} \right\rfloor + 1\) est un parent. Alors,
  son fils gauche est stocké en
  \(2\left(\left\lfloor \frac{n}{2} \right\rfloor + 1\right)\). Or
  \[ \left\lfloor \frac{n}{2} \right\rfloor + 1 > {n \over 2} \iff 2\left(\left\lfloor \frac{n}{2}\right\rfloor + 1\right) > n. \]
  Donc, l'indice étant en dehors du tableau, il n'a pas de fils. C'est
  donc une feuille.

  Soit
  \(k \in \left[\kern-2mm\left[ 1, \left\lfloor {n \over 2} \right\rfloor\;\; \kern-1mm\right]\kern-2mm\right]\).
  \(k \times 2 \leqslant 2\) donc \(k\) a un fils donc ce n'est pas une
  feuille.
\end{enumerate}

\hypertarget{opuxe9rations-sur-les-tas}{%
\subsection{Opérations sur les tas}\label{opuxe9rations-sur-les-tas}}

Trois opérations

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Préservation de la propriété des tas max
\end{enumerate}

\begin{quote}
\begin{quote}
Reçoit un tableau et un indice du tableau
\end{quote}
\end{quote}

\begin{quote}
\begin{quote}
Modifie le tableau pour qu'il contienne un tas max
\end{quote}
\end{quote}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Construction d'un tas max
\end{enumerate}

\begin{quote}
\begin{quote}
Reçoit un tableau
\end{quote}
\end{quote}

\begin{quote}
\begin{quote}
Retourne un tas max
\end{quote}
\end{quote}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Tri par tas
\end{enumerate}

\begin{quote}
\begin{quote}
Tri d'un tableau par ordre croissant (décroissant) en utilisant les
propriétés d'un tas max (min).
\end{quote}
\end{quote}

\hypertarget{conservation-de-la-propriuxe9tuxe9-des-tas-max}{%
\subsubsection{Conservation de la propriété des tas
max}\label{conservation-de-la-propriuxe9tuxe9-des-tas-max}}

(code sur la feuille)

\emph{État de l'arbre et du tableau pour l'appel de
\texttt{entasserMax(A,\ 2)} avec}
\[\mathit{A = [\;20,15,17,34,5,7,12,10,16\;]\kern3mm \text{\it?}} \]

Après une itération, on a \(A = [\;20,34,17,15,5,7,12,10,16\;]\).

Après deux itération, on a \(A = [\;20,34,17,16,5,7,12,10,15\;]\).

\includegraphics{.cache/mermaid/23edb761357acf79138981a61cc90869.pdf}

devient

\includegraphics{.cache/mermaid/3fa43b61d3f69c6c90cc02b92db3937e.pdf}

\emph{Que représente \(i\) pour l'arbre résultant ?}

Le \(i\) représente l'indice dans le tableau de l'arbre de la racine du
tas max que l'on veut former.

Fonction \texttt{entasserMax} :

\begin{itemize}
\item
  Reçoit un tableau \(A\) représentant un tas,\vspace{-2mm}
\item
  Reçoit un \(i\),\vspace{-2mm}
\item
  Retourne \(A\) modifié.\vspace{3mm}
\item
  \texttt{entasserMax} fait l'hypothèse que les sous arbres gauche et
  droit du nœud \(i\) sont des tais mais que le nœud \(i\) est peut être
  plus petit que ses enfant.\vspace{3mm}
\item
  \texttt{entasserMax} fait alors descendre le nœud \(i\) jusqu'à ce que
  la propriété de tas max soit rétablie localement.\vspace{3mm}
\item
  Complexité en \(\mathcal{O}(\ln n) = \mathcal{O}(h)\)
\end{itemize}

Fonction \texttt{construireTasMax}:

\begin{itemize}
\tightlist
\item
  Construction d'un tas,
\item
  Conversion en tas max,
\item
  Invariant : au début de chaque itération de la boucle pour, chaque
  nœud \(i+1, i+2, \ldots, n\) est la racine d'un tas max,
\item
  Complexité en \(T(n) = \mathcal{O}(n\ln n)\).
\end{itemize}

\hypertarget{tri-par-tas-heap-sort}{%
\subsection{\texorpdfstring{Tri par tas (\emph{heap
sort})}{Tri par tas (heap sort)}}\label{tri-par-tas-heap-sort}}

On fait remonter la dernière valeur du tableau en l'interchangeant avec
la racine du tas (la plus grande valeur). Pour éviter de faire remonter
la plus grande valeur à la racine, on diminue la taille du tas. On
recrée un tas local en replaçant la valeur maximale à la racine.

Première étape : \vspace{-2mm}

\begin{quote}
Construction du tas max \vspace{-2mm}
\end{quote}

\begin{quote}
La première valeur est la racine donc l'élément de clé la plus grande.
\end{quote}

\begin{quote}
\vspace{-2mm}

On place cet élément en dernier.
\end{quote}

Seconde étape : \vspace{-2mm}

\begin{quote}
On rétablit la propriété de tas max sur le tableau privé du dernier
élément.
\end{quote}

Répétition du processus jusqu'à arriver à un tas de taille 2.

Complexité en \(\mathcal{O}(n \ln n)\).
